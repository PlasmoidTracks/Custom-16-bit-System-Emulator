
r0 is a general purpose register, usually holding addresses
r1 is a general purpose register, usually holding expressions
r2 is probably gonna be used as a counter for loops? NEW IDEA: Use as cache for frequently used variables IN THE OPTIMIZER!
r3 is the frame pointer, in case the functions uses arguments and the sp is used for local memory



TODO GENERAL!!!:
MMIO        - interrupts that print to terminal
ADC / SBC   - necessary for 32-bit value emulation ???
Check wether 32-bit value emulation is possible



BUGS:
commented strings count as strings : // "string"
keywords only check prefix, so "variable" turns into "var"/LEX_VAR + "iable"/LEX_IDENTIFIER



Currently strings in stack are reversed!

TODO for IR:
more verbose errors
array allocation (no, this is a feature of higher level languages, we alread got anon's)
string values (16-bit per char) (perhaps same reasoning as arrays? Keep them in higher level langs, though asm DOES support strings...)
display the scope context for variable names in the commented section after variable fetch in asm
warn on assigning too large values
make the lexer check for FULL words, not just check for matching prefixes
make code segments explicitly use ".code", or should it be part of the IR?
string assignment (var = "test";) [NO, this is high level]
add copmiler options:
- keep comments             inserts the original comments into the assembly
- show variable names       shows the refered variable name at the instruction that moves the variable into a register
- verbose                   show the compiler steps like "variable assignment" etc. 
allow negative number assignments "ident = -1;"
interrupt vector function definitions? (done with irqbegin / irqend)



Deoptimizer Idea: 
Similar to peephole optimization step, but replaces complex operations with simpler ones. 
One example would be replacing multiplication with looped addition


Add timing to know which compile steps takes how long


Other TODO:
Dirty cachelines
GUI
snapshots (export import of cpu state (also ram, bus, etc))
add binary dump as well of finished program?



rules: 

variables and binary operations can ONLY be done on the SAME type. 
Thus casting should be handled by the user / higher level language. 


Then the next higher language could do this:
lets assume ix, iy, iz etc are integers and fx, fy, fz etc are floats:

ix = fx
would translate to this, which would include a temporary variable for type conversion:
var tmpx;
tmpx = fti fx;
ix = tmpx;

ix = fx + fy;
would translate to this:
var tmpx;
tmpx = fti fx;
var tmpy;
tmpy = fti fy;
ix = tmpx + tmpy;


Add note to Report, that optimizer is not safe for custom asm, only for ir output. 



The OPTIMIZER requires some normalization to work, especially for indirect offset and scaled offset optimizations

NEW OPTIMIZATIONS: 

mov rN, ?
mov rM, sp
mov [rM], rN
->
mov rM, sp
mov [rM], ?
// as long as rM != rN and not status checks, and also only if rN is fully replaced before reuse... 



Also: 
cmp r0, 1
mov r1, 0
cmovnl r1, 1
cmovz r1, 0
->
cmp r0, 1
mov r1, 0
cmovnl r1, 1
(delete)


cmp r0, 1
mov r1, 0
cmovnl r1, 1
cmovz r1, 0
->
cmp r0, 1
mov r1, sp
and r1, $0002


lea r0, [$FFF6 + r3]
mov [r0], r1
mov r1, [$FFF6 + r3]
tst r1
->
lea r0, [$FFF6 + r3]
mov [r0], r1
tst r0

