// This script contains some utility functions

static var _time;
static var _malloc_address;
_malloc_address = 0xa000;

.main
    scopebegin;

    // setting up interrupt address for INT_CLOCK vector
    var address;
    address = 0x7f02;
    var funcptr;
    funcptr = .irq_ticker;
    deref address = funcptr;

    var result;
    var presult;
    presult = ref result;
    callpusharg f0.5;
    callpusharg f2;
    callpusharg presult;
    call .powerf;
    callfreearg 6;
    asm "mov r2, result";

    scopeend;
    return;


.malloc
    scopebegin;

    var psize;
    psize = arg i+ 2;
    var size;
    size = deref psize;

    var ppout;
    ppout = arg i+ 0;

    var pout;
    pout = deref ppout;

    deref _malloc_address = size;
    _malloc_address = _malloc_address i+ 2;

    deref pout = _malloc_address;
    _malloc_address = _malloc_address i+ size;

    scopeend;
    return;


.factorial
    scopebegin

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;

    var pout;
    pout = deref ppout;

    var i;
    i = 2;

    var value;
    value = 1;

    .factorial_L
    var condition;
    condition = i i> x;
    if condition .factorial_end;
    value = value i* i;
    i = i i+ 1;
    goto .factorial_L;

    .factorial_end

    deref pout = value;

    scopeend
    return;


.factorialf
    scopebegin

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;

    var pout;
    pout = deref ppout;

    var i;
    i = f2;

    var value;
    value = f1;

    .factorialf_L
    var condition;
    condition = i f> x;
    if condition .factorialf_end;
    value = value f* i;
    i = i f+ f1;
    goto .factorialf_L;

    .factorialf_end

    deref pout = value;

    scopeend
    return;


.factoriald
    scopebegin

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;

    var pout;
    pout = deref ppout;

    var i;
    i = d2;

    var value;
    value = d1;

    .factoriald_L
    var condition;
    condition = i d> x;
    if condition .factoriald_end;
    value = value d* i;
    i = i d+ d1;
    goto .factoriald_L;

    .factoriald_end

    deref pout = value;

    scopeend
    return;


.sinf
    scopebegin;

    // for values between 0 and pi/2, we can approximate sin(x) with the following polynomial:
    // sin(x) = ((24 - 4pi) / pi²)x + ((12pi - 48) / pi³)x²

    scopeend;
    return;


.expf
    scopebegin

    // sum from n = 0 to n = 5 (x^n) / (n!)
    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    var i;
    i = 0;

    var result;
    result = f0;

    var k;  // the integer part of x
    k = x;
    k = cfi k;
    k = cif k;

    var l;  // the fractional part
    var condition;
    condition = x f> f0;
    if condition .expf_L4;
    var tmp;
    tmp = f0 f- x;
    l = tmp f+ k;
    l = f0 f- l;
    goto .expf_L5;
    .expf_L4;
    l = x f- k;
    .expf_L5;

    .expf_L
    condition = i i>= 16;
    if condition .expf_end;

    var top_term;
    var ptop_term;
    ptop_term = ref top_term;
    var float_i;
    float_i = cif i;
    callpusharg float_i;
    callpusharg l;
    callpusharg ptop_term;
    call .ipowerf;
    callfreearg 6;

    var inf_condition;
    inf_condition = top_term i== 0x7C00 ;
    if inf_condition .expf_end;

    var bottom_term;
    var pbottom_term;
    pbottom_term = ref bottom_term;
    callpusharg float_i;
    callpusharg pbottom_term;
    call .factorialf;
    callfreearg 4;

    var term;
    term = top_term f/ bottom_term;
    result = result f+ term;

    i = i i+ 1;
    goto .expf_L;

    .expf_end

    // now multiply result by e k times
    .expf_L2
    condition = k f<= f0;
    if condition .expf_L3;
    result = result f* f2.718281828459;
    k = k f- f1;
    goto .expf_L2;

    // and divide result by e -k times
    .expf_L3
    condition = k f>= f0;
    if condition .expf_end2;
    result = result f/ f2.718281828459;
    k = k f+ f1;
    goto .expf_L3;

    .expf_end2
    deref pout = result;

    scopeend
    return;


.expd
    scopebegin

    // sum from n = 0 to n = 5 (x^n) / (n!)
    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    var i;
    i = 0;

    var result;
    result = d0;

    var k;  // the integer part of x
    k = x;
    k = cdi k;
    k = cid k;

    var l;  // the fractional part
    var condition;
    condition = x d> d0;
    if condition .expd_L4;
    var tmp;
    tmp = d0 d- x;
    l = tmp d+ k;
    l = d0 d- l;
    goto .expd_L5;
    .expd_L4;
    l = x d- k;
    .expd_L5;

    .expd_L
    condition = i i>= 16;
    if condition .expd_end;

    var top_term;
    var ptop_term;
    ptop_term = ref top_term;
    var dloat_i;
    dloat_i = cid i;
    callpusharg dloat_i;
    callpusharg l;
    callpusharg ptop_term;
    call .ipowerd;
    callfreearg 6;

    var inf_condition;
    inf_condition = top_term i== 0x7F80 ;
    if inf_condition .expd_end;

    var bottom_term;
    var pbottom_term;
    pbottom_term = ref bottom_term;
    callpusharg dloat_i;
    callpusharg pbottom_term;
    call .factoriald;
    callfreearg 4;

    var term;
    term = top_term d/ bottom_term;
    result = result d+ term;

    i = i i+ 1;
    goto .expd_L;

    .expd_end

    // now multiply result by e k times
    .expd_L2
    condition = k d<= d0;
    if condition .expd_L3;
    result = result d* d2.718281828459;
    k = k d- d1;
    goto .expd_L2;

    // and divide result by e -k times
    .expd_L3
    condition = k d>= d0;
    if condition .expd_end2;
    result = result d/ d2.718281828459;
    k = k d+ d1;
    goto .expd_L3;

    .expd_end2
    deref pout = result;

    scopeend
    return;


.ipowerf
    scopebegin;

    var pn;
    pn = arg i+ 4;
    var n;
    n = deref pn;

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    // currently only handling integer values despite float argument
    // rouding n to nearest integer form

    var result;
    result = f1;

    //while (n > 0) {result *= x; n--}
    var condition;
    .ipowerf_L
    condition = n f<= f0;
    if condition .ipowerf_end;

    result = result f* x;
    n = n f- f1;

    goto .ipowerf_L;

    .ipowerf_end

    deref pout = result;

    scopeend;
    return;


.ipowerd
    scopebegin;

    var pn;
    pn = arg i+ 4;
    var n;
    n = deref pn;

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    // currently only handling integer values despite float argument
    // rouding n to nearest integer form

    var result;
    result = d1;

    //while (n > 0) {result *= x; n--}
    var condition;
    .ipowerd_L
    condition = n d<= d0;
    if condition .ipowerd_end;

    result = result d* x;
    n = n d- d1;

    goto .ipowerd_L;

    .ipowerd_end

    deref pout = result;

    scopeend;
    return;


.lnf
    scopebegin;

    // ln(x) = sum[n=1 to inf](-1^(n-1) * (x-1)^n / n) [works only for 0 < x < 2]
    // and ln(n * e^k) = ln(n) + ln(e^k) = ln(n) + k
    // so divide x by e until x is lower than 2.0

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    // if x <= 0 return inf

    var condition;
    condition = x f> f0;
    if condition .lnf_continue;
    deref pout = 0x7c00; // inf in float16
    goto .lnf_end;
    .lnf_continue

    var k;
    k = f0;

    // while (x > 2.0) {k += 1.0; x /= 2.718281828459;}
    .lnf_L1
    condition = x f<= f2;
    if condition .lnf_L1end;
    k = k f+ f1;
    x = x f/ f2.718281828459;
    goto .lnf_L1;
    .lnf_L1end

    // ln(x') = k * sum[n=1 to inf](-1^(n-1) * (x'-1)^n / n)
    var n;
    n = f1;
    var alternating;
    alternating = f1;
    var result;
    result = f0;

    .lnf_Lsum
    condition = n f>= f10;
    if condition .lnf_Lsum_end;

    var x_minus_1;
    x_minus_1 = x f- f1;
    var pow;
    var ppow;
    ppow = ref pow;
    callpusharg n;
    callpusharg x_minus_1;
    callpusharg ppow;
    call .ipowerf;
    callfreearg 6;

    var intermediate;
    intermediate = alternating f* pow;
    intermediate = intermediate f/ n;
    result = result f+ intermediate;

    alternating = alternating f* 0xbc00;    // -1.0
    n = n f+ f1;
    goto .lnf_Lsum;

    .lnf_Lsum_end

    result = result f+ k;

    deref pout = result;

    .lnf_end
    scopeend;
    return;


.lnd
    scopebegin;

    // ln(x) = sum[n=1 to inf](-1^(n-1) * (x-1)^n / n) [works only for 0 < x < 2]
    // and ln(n * e^k) = ln(n) + ln(e^k) = ln(n) + k
    // so divide x by e until x is lower than 2.0

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    // if x <= 0 return inf

    var condition;
    condition = x d> d0;
    if condition .lnd_continue;
    deref pout = 0x7f80; // inf in dloat16
    goto .lnd_end;
    .lnd_continue

    var k;
    k = d0;

    // while (x > 2.0) {k += 1.0; x /= 2.718281828459;}
    .lnd_L1
    condition = x d<= d2;
    if condition .lnd_L1end;
    k = k d+ d1;
    x = x d/ d2.718281828459;
    goto .lnd_L1;
    .lnd_L1end

    // ln(x') = k * sum[n=1 to inf](-1^(n-1) * (x'-1)^n / n)
    var n;
    n = d1;
    var alternating;
    alternating = d1;
    var result;
    result = d0;

    .lnd_Lsum
    condition = n d>= d10;
    if condition .lnd_Lsum_end;

    var x_minus_1;
    x_minus_1 = x d- d1;
    var pow;
    var ppow;
    ppow = ref pow;
    callpusharg n;
    callpusharg x_minus_1;
    callpusharg ppow;
    call .ipowerd;
    callfreearg 6;

    var intermediate;
    intermediate = alternating d* pow;
    intermediate = intermediate d/ n;
    result = result d+ intermediate;

    alternating = alternating d* 0xd80;    // -1.0
    n = n d+ d1;
    goto .lnd_Lsum;

    .lnd_Lsum_end

    result = result d+ k;

    deref pout = result;

    .lnd_end
    scopeend;
    return;


.powerf
    scopebegin;

    // x^n = e^(ln(x) * n)

    var pn;
    pn = arg i+ 4;
    var n;
    n = deref pn;

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;    

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;
    
    var k;  // the integer part of x
    k = n;
    k = cfi k;
    k = cif k;

    var condition;
    condition = n i!= k;
    if condition .powerf_skip;

    callpusharg k;
    callpusharg x;
    callpusharg pout;
    call .ipowerf;
    callfreearg 6;
    goto .powerf_end;
    .powerf_skip

    var lnx;
    var plnx;
    plnx = ref lnx;

    callpusharg x;
    callpusharg plnx;
    call .lnf;
    callfreearg 4;

    lnx = lnx f* n;

    callpusharg lnx;
    callpusharg plnx;
    call .expf;
    callfreearg 4;

    deref pout = lnx;

    .powerf_end

    scopeend;
    return;


.powerd
    scopebegin;

    // x^n = e^(ln(x) * n)

    var pn;
    pn = arg i+ 4;
    var n;
    n = deref pn;

    var px;
    px = arg i+ 2;
    var x;
    x = deref px;

    var ppout;
    ppout = arg i+ 0;
    var pout;
    pout = deref ppout;

    var k;  // the integer part of x
    k = n;
    k = cdi k;
    k = cid k;

    var condition;
    condition = n i!= k;
    if condition .powerd_skip;

    callpusharg k;
    callpusharg x;
    callpusharg pout;
    call .ipowerd;
    callfreearg 6;
    goto .powerd_end;
    .powerd_skip

    var lnx;
    var plnx;
    plnx = ref lnx;

    callpusharg x;
    callpusharg plnx;
    call .lnd;
    callfreearg 4;

    lnx = lnx d* n;

    callpusharg lnx;
    callpusharg plnx;
    call .expd;
    callfreearg 4;

    deref pout = lnx;

    .powerd_end

    scopeend;
    return;


.sleep
    scopebegin;

    var dt;
    dt = deref arg;

    var target_time;
    target_time = _time i+ dt;

    .sleep_L
    var condition;
    condition = _time i< target_time;
    if condition .sleep_L;

    scopeend;
    return;


.irq_ticker
    irqbegin
    _time = _time i+ 1;
    irqend
    return;


