static var N;
N = 0;
static var recursive_function_calls;
recursive_function_calls = 0;
static var time;
time = 0;

.main
    scopebegin;

    // setting up interrupt address for INT_CLOCK vector
    var address;
    address = 0x7f02;
    var funcptr;
    funcptr = .irq_handler;
    deref address = funcptr;

    N = 16;

    // create the output variable and set to -1
    var result;
    result = 0i-1;

    // create reference of output variable for the function parameter
    var ptr_result;
    ptr_result = ref result;

    callpusharg ptr_result;
    callpusharg N;
    call .fib;
    callfreearg 4;
    
    asm "mov r0, result";
    asm "mov r1, time";
    asm "mov r2, recursive_function_calls";
    scopeend;
    return;

.fib
    scopebegin;

    recursive_function_calls = recursive_function_calls i+ 1;

    // get return argument
    var ptrptr_result;
    ptrptr_result = arg i+ 2;
    var ptr_result;
    ptr_result = deref ptrptr_result;

    // get argument
    var ptr_arg_N;
    ptr_arg_N = arg i+ 0;
    var arg_N;
    arg_N = deref ptr_arg_N;

    // check if arg_N <= 1
    var condition;
    condition = arg_N i> 1;

    if condition .valid;
    deref ptr_result = arg_N;
    return
    .valid
    
    // return fib(n-2) + fib(n-1)
    var result_N_minus_2;
    var ptr_result_N_minus_2;
    ptr_result_N_minus_2 = ref result_N_minus_2;
    var N_minus_2;
    N_minus_2 = arg_N i- 2;
    callpusharg ptr_result_N_minus_2;
    callpusharg N_minus_2;
    call .fib;
    callfreearg 4;

    var result_N_minus_1;
    var ptr_result_N_minus_1;
    ptr_result_N_minus_1 = ref result_N_minus_1;
    var N_minus_1;
    N_minus_1 = arg_N i- 1;
    callpusharg ptr_result_N_minus_1;
    callpusharg N_minus_1;
    call .fib;
    callfreearg 4;

    var sum;
    sum = result_N_minus_2 i+ result_N_minus_1;
    deref ptr_result = sum;

    scopeend;
    return;

.irq_handler
    irqbegin
    time = time i+ 1;
    irqend
    return;

